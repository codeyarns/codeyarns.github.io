<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Ashwin Nanjappa" />
  <title>Aligned memory allocation</title>
  <style type="text/css">code{white-space: pre;}</style>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-143311697-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
  
    gtag('config', 'UA-143311697-1');
  </script>
</head>
<body>
<div id="header">
<h1 class="title">Aligned memory allocation</h1>
<h2 class="author">Ashwin Nanjappa</h2>
<h3 class="date">2017-02-28 14:04:42+00:00</h3>
</div>
<p>In some scenarios, you want to get memory that is <strong>aligned</strong> at an address that is a certain power of 2. Certain CPU architectures and certain operations require (or are faster) if their operands are located at an address that is a multiple of a certain power-of-2 number. For these reasons, you might see that many multi-platform libraries use an aligned memory allocator instead of <strong>malloc</strong> in their code. For example, OpenCV uses methods named <strong>fastMalloc</strong> and <strong>fastFree</strong> inside its code that do this type of allocation and freeing.</p>
<p>Most of these methods work like this:</p>
<ul>
<li><p>They internally get memory from malloc. However, if you requested for N bytes, the wrapper will request for N+P+A bytes from malloc. Here, P is the size of a pointer on that CPU architecture and A is the alignment required, expressed in power-of-2 number of bytes. For example, if I request for 100 bytes on a 64-bit CPU and require the memory to be aligned to a multiple of 32, then the wrapper will request for 140 bytes.</p></li>
<li><p>After getting the memory from malloc, it aligns the pointer forward so that (1) the pointer is at an address that is aligned as per requirement and (2) there is space behind the pointer to store a memory address.</p></li>
<li><p>Then we sneak and store the address actually returned by malloc behind the pointer address and return the pointer to the user.</p></li>
<li><p>The user has to use our free wrapper to free this pointer. When she does that we sneak back to reveal the actual address returned by malloc and free using that.</p></li>
</ul>
<p>Here is some example code that illustrates aligned memory allocation:</p>
<p>https://gist.github.com/ashwin/acde4e7bff4b1bc86e5216931fadea5b</p>
</body>
</html>
