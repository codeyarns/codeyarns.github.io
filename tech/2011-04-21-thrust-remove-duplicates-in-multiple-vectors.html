<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Ashwin Nanjappa" />
  <title>Code Yarns â€“ Thrust: Remove Duplicates in Multiple Vectors</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-143311697-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
  
    gtag('config', 'UA-143311697-1');
  </script>
  <!-- CSS styles -->
  <style>
  p.caption {
      text-align: center;
  }
  img {
      max-width: 90%;
      display: block;
      margin: 0 auto;
  }
  </style>
</head>
<body>
<a href="..">Code Yarns</a> / <a href="index.html">Tech Blog</a>
<hr />
<div id="header">
<h1 class="title">Thrust: Remove Duplicates in Multiple Vectors</h1>
<h3 class="date">2011-04-21 03:56:36+00:00</h3>
</div>
<p>With the magical <code>thrust::zip_iterator</code> duplicates in multiple vectors can be easily removed and the vectors can be trimmed in <strong>Thrust</strong>.</p>
<p>Consider two vectors, one of <strong>key</strong> values and the other holding their <strong>values</strong>. There can be many values associated with each key. The keys are sorted and the values associated with each key are also sorted. Finding duplicates in these vectors boils down to finding duplicate pairs and removing them. Here is how to achieve this easily using <code>thrust::unique</code> and <code>thrust::zip_iterator</code>:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> thrust::device_vector&lt; <span class="dt">int</span> &gt;                IntVector;
<span class="kw">typedef</span> IntVector::iterator                         IntIterator;
<span class="kw">typedef</span> thrust::tuple&lt; IntIterator, IntIterator &gt;   IntIteratorTuple;
<span class="kw">typedef</span> thrust::zip_iterator&lt; IntIteratorTuple &gt;    ZipIterator;

IntVector keyVector;
IntVector valVector;

<span class="co">// Remove duplicate pairs</span>
ZipIterator newEnd = thrust::unique( thrust::make_zip_iterator( thrust::make_tuple( keyVector.begin(), valVector.begin() ) ),
                                     thrust::make_zip_iterator( thrust::make_tuple( keyVector.end(), valVector.end() ) ) );

IntIteratorTuple endTuple = newEnd.get_iterator_tuple();

<span class="co">// Trim the vectors</span>
keyVector.erase( thrust::get&lt;<span class="dv">0</span>&gt;( endTuple ), keyVector.end() );
valVector.erase( thrust::get&lt;<span class="dv">1</span>&gt;( endTuple ), valVector.end() );</code></pre></div>
<p><strong>Tried with</strong>: Thrust 1.3 and CUDA 3.2</p>
<hr />
<p><a href="rss.xml">RSS</a> - <a href="mailto:codeyarns@gmail.com">Contact</a></p>
</body>
</html>
