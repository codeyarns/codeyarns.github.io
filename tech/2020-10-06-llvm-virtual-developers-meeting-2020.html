<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="Ashwin Nanjappa">
  <title>Code Yarns ‚Äì LLVM Virtual Developers' Meeting 2020</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="../styles.css">
  <!-- RSS feed -->
  <link rel="alternate" type="application/rss+xml" href="https://codeyarns.github.io/tech/rss.xml" />
  <!-- Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-143311697-1">
  </script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
  
    gtag('config', 'UA-143311697-1');
  </script>
  <!-- Google Adsense -->
  <script data-ad-client="ca-pub-1956250892185343" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
  </script>
  <!-- Twitter button -->
  <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
</head>

<body>

<div class="contentbox">
<div class="header">
    <a href=".." class="header">Code Yarns ‚Äçüë®‚Äçüíª</a>
  </div>
  <div class="header">
    <a class="header2" href="https://codeyarns.github.io/tech/">Tech Blog</a> ‚ùñ <a class="header2" href="https://codeyarns.github.io/personal/">Personal Blog</a>
  </div>
  <div class="header" style="padding-top: 10px;">
    <iframe src="https://duckduckgo.com/search.html?site=codeyarns.github.io&kp=-2&kc=1&prefill=Search this website" style="width:300px;height:40px;" frameborder="0"></iframe>
</div>
</div>

<br />

<div class="contentbox">
<header>
<h1 class="title">LLVM Virtual Developers' Meeting 2020</h1>
<p class="date">üìÖ 2020-Oct-06 ‚¨© ‚úçÔ∏è Ashwin Nanjappa ‚¨© üìö <a href="index.html">Archive</a></p>
</header>
<p>I had been meaning to attend the <a href="https://llvm.org/devmtg/"><strong>LLVM Developers' Meeting</strong></a> for a couple of years now, mostly because it happens right next door in San Jose. <a href="https://llvm.org/devmtg/2020-09/">This year</a> the conference went virtual and actually made it easy for me to finally attend all 3 days <strong>(Oct 6-8)</strong>. Below are my notes from the talks I attended from their multiple-track agenda. This being the first time I am attending a compiler conference, let alone a LLVM one, I focused on gaining basic knowledge of the software architecture of compilers, usage of common tools and techniques in the field.</p>
<h2 id="day-1">Day 1</h2>
<h3 id="everything-i-know-about-debugging-llvm">Everything I know about debugging LLVM</h3>
<ul>
<li>Talk by Nick Desaulniers, who works on compiling the Linux kernel with LLVM at Google. (<a href="https://clangbuiltlinux.github.io/llvm-dev-conf-2020/nick/debugging_llvm.html#/">Slides</a>)</li>
<li>Begins with a brief introduction to stages of C++ code compilation with clang and the LLVM source code paths of those modules.</li>
<li>The clang driver converts C++ code to LLVM IR. Stages in it are preprocessor, lexer, parser (generates AST), SEMA (Semantic Analysis and Template Instantiation) and LLVM IR emission (CodeGen).</li>
<li>Abstractions of input code in LLVM are llvm::module (translation unit), llvm::function, llvm::basicBlock and llvm::Instruction.</li>
<li>IR has 3 representations: in-memory during runtime, textual for read/write by humans and binary serialized for files.</li>
<li>CodeGen: General code generation happens in llvm/lib/CodeGen and machine specific code generation happens in llvm/lib/target/XYZ</li>
<li>There are four types of register allocators.</li>
<li>ASM streamer writes the different types of object files.</li>
<li>Building LLVM: cmake to generate build files, ninja to invoke build.</li>
<li>LLD is faster than BFD. BFD is the default linker on Linux.</li>
<li>llvm-readelf tool can be used to check if a library file was built using LLVM.</li>
<li>opt tool can be used to run different optimizations on IR files.</li>
<li>creduce and cvise can be used to do test case reduction.</li>
<li>LLVM weekly and blog are good resources.</li>
<li>&quot;The master has failed more times than the disciple has even tried.&quot;</li>
</ul>
<h3 id="llvm-in-a-bare-metal-environment">LLVM in a Bare Metal Environment</h3>
<ul>
<li>Talk by Hafiz Abid Qadeer.</li>
<li>A typical compiled binary or library runs atop of the OS and with the support of dynamically linked libraries. This talk was about how to compile a binary that can run baremetal on hardware with no OS in between using the LLVM toolchain.</li>
<li>I dropped out halfway from this talk because this was a topic which was not relevant to me.</li>
</ul>
<h3 id="branch-coverage-squeezing-more-out-of-llvm-source-based-code-coverage">Branch Coverage: Squeezing more out of LLVM Source-based Code Coverage</h3>
<ul>
<li>Talk by Alan Phipps.</li>
<li>LLVM's coverage tool has support for function, line and region coverage. But it does not have branch coverage, which the speaker added.</li>
<li>Counters are used at function, statement and condition and incremented when they are executed.</li>
<li>Using simple if conditions, the speaker explained how he added counters to add branch coverage.</li>
<li>MC/DC is a future work once branch coverage is checked into LLVM.</li>
<li>GCC gcov (console output) and lcov (HTML output) are the competitors which already have branch coverage, with some caveats.</li>
</ul>
<h3 id="checked-c-adding-memory-safety-support-to-llvm">Checked C: Adding memory safety support to LLVM</h3>
<ul>
<li>Talk by Mandeep Singh Grang and Katherine Kjeer.</li>
<li>Checked C adds 3 new pointer types to C to handle buffer overflow and null pointer dereference.</li>
<li>New pointer types are <code>_Ptr&lt;T&gt;</code>, <code>_Array_ptr&lt;T&gt;</code> and <code>_Nt_array_ptr&lt;T&gt;</code>.</li>
<li>There exists a Checked C tool that can convert C code to Checked C code.</li>
</ul>
<h2 id="day-2">Day 2</h2>
<h3 id="using-clang-tidy-for-customized-checkers-and-large-scale-source-tree-refactoring">Using clang-tidy for customized checkers and large scale source tree refactoring</h3>
<ul>
<li>Talk by Vince Bridgers.</li>
<li>Most bugs are introduced early in the development process, but discovered and fixed late. Thus the cost of having a bug in the code is pretty high. Weeding out bugs as early as possible reduces software cost.</li>
<li>Types of program analysis tools:</li>
<li>Compiler diagnostics: Warnings from GCC and Clang. Part of compilation.</li>
<li>Linters and style checkers: Use text/AST matching. An extra step after compilation.</li>
<li>Static analysis: cppcheck, GCC 10+, clang. These use symbolic execution. An extra step after compilation.</li>
<li>Dynamic analysis: valgrind, gcc, clang. Injection of runtime checks or library. Long runtimes due to running extra code. An extra step after compilation.</li>
<li>LLVM compiler flow is: Frontend -&gt; Optimizer -&gt; CodeGen</li>
<li>clang-tidy: Uses AST matchers to find and replace patterns. It has full access to AST and preprocessor. There are 200+ existing checks. It is extensible to add custom checks.</li>
<li><code>clang-tidy --list-checks</code>: To list all currently active checks. This is <em>not</em> the full list of available checks.</li>
<li><code>clang-tidy --list-checks -checks=*</code>: Lists all available checks.</li>
<li><code>clang-tidy ... -checks=-*,&lt;your specific check&gt;</code>: To pick out a specific check to apply.</li>
<li><code>clang-tidy ... --fix</code>: Not just check, but also fix the errors found.</li>
<li><a href="https://clang.llvm.org/extra/clang-tidy/checks/list.html">Full list</a> of available checks. Checks with fixes are indicated in the second column.</li>
<li><code>clang-query</code> is an interactive tool to play around with clang C++ API to query AST and figure out the calls to match a pattern.</li>
<li>Write the new custom check (and fix) in C++ code and add to clang-tidy using <code>add_new_check.py &lt;category&gt; &lt;check name&gt;</code></li>
<li>There are clang-tidy tools to apply checks across an entire codebase in parallel without the fixes overwriting on each other.</li>
</ul>
<h3 id="llvm-libc-current-status-challenges-and-future-plans">LLVM Libc: Current Status, Challenges and Future Plans</h3>
<ul>
<li>Talk by Siva Chandra Reddy.</li>
<li>Motivations to create a new cleanroom implementation of libc: sanitizer friendly, use standard C/C++ and no assembly and to make it modular so that users can mix libc pieces from different libc implementations (like GNU libc and MUSL).</li>
<li>LLVM libc uses C++ templates internally to reduce code for different variants of math functions.</li>
<li>threads.h (mutex and thread functions) and signal.h will be platform specific code.</li>
<li>mmap, munmap: Used for creation and destruction of thread stacks for threads.</li>
<li>Loader: It starts the user application calling main at the end and also cleans up after the application has ended.</li>
<li>Static-PIE ELF loader is in the works.</li>
<li>It will be a few years before this has all the libc functions and can fully replace GNU libc on just Linux. Other platforms are more years away.</li>
</ul>
<h3 id="accelerate-matrix-multiplication-using-the-new-power-outer-product-instructions">Accelerate Matrix Multiplication Using the New POWER Outer Product Instructions</h3>
<ul>
<li>Talk by Baptiste Saleil and Jo√£o Carvalho.</li>
<li>MMA instructions have been added to PowerISA 3.1. So they will be available in POWER10 and later CPUs.</li>
<li>The motivation is to speedup kernels of matrix multiplication and convolutions used in deep learning.</li>
<li>8 new accumulators which are 512-bit registers. Each accumulator is associated with 4 existing 128-bit VSR registers.</li>
<li>3 types of instructions have been added:</li>
<li>Move data to and from MMA accumulators: To move data to accumulator or set to zero use primed instructions (VSR-&gt;acc). To move data from accumulator use unprimed instruction (acc-&gt;VSR).</li>
<li>Integer MMA instructions: Multiply two 4x2 inputs to produce 4x4 output. Inputs are typically lower precision (Ex: INT16) than outputs (Ex: INT32). Available for all INT types like INT16, INT32, INT8, INT4.</li>
<li>Floating point MMA instructions: Multiply two 4x2 inputs to produce 4x4 output. Same as INT above. Available for all supported float types: FP64, FP32, FP16 and Bfloat16.</li>
<li>New API has been added based on LLVM compiler intrinsics.</li>
<li>New optimization pass has been added to LLVM to identify GEMM variants in IR to map to MMA instructions.</li>
<li>LLVM recently added <code>llvm.matrix.*</code> instructions that can be used for this mapping. <code>llvm.matrix.column.major.load()</code> to load matrix for MMA and <code>llvm.matrix.multiply()</code> to do MMA.</li>
</ul>
</div>

<br />

<div class="contentbox">

<div class="footer"><a href="mailto:codeyarns@gmail.com" style="text-decoration: none; font-size: xx-large;">üìß</a> <a href="https://twitter.com/codeyarns" class="twitter-follow-button" data-show-count="false" data-size="large">Follow @codeyarns</a> <a href="https://www.buymeacoffee.com/codeyarns"><img src="https://cdn.buymeacoffee.com/buttons/default-orange.png" alt="Buy Me A Coffee" style="height: 38px !important;width: 163px !important;" ></a></div>
</div>

</body>
</html>
