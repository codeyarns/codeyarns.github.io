<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="Ashwin Nanjappa">
  <title>Code Yarns â€“ CUDA: Timer</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="../styles.css">
  <!-- Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-143311697-1">
  </script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
  
    gtag('config', 'UA-143311697-1');
  </script>
  <!-- Google Site Search -->
  <script async src="https://cse.google.com/cse.js?cx=003521915278168649297:cryrlg7hahe">
  </script>
</head>
<body>
<table style="width: 100%;">
    <tr>
        <td>
            <a href="..">Code Yarns</a> / <a href="index.html">Tech Blog</a>
        </td>
        <td>
            <div class="gcse-search"></div>
        </td>
    </tr>
</table>
<hr style="margin-top: 0px;" />
<header>
<h1 class="title">CUDA: Timer</h1>
<p class="date">2011-04-28 08:19:22+00:00</p>
</header>
<p>To measure the performance of <strong>CUDA</strong> code it is better to use <strong>events</strong> provided by the <strong>CUDA Runtime API</strong> rather than using CPU-based timers like <a href="http://codeyarns.wordpress.com/2010/05/25/c-timing-the-code/">clock</a> or <a href="http://codeyarns.wordpress.com/2011/04/08/c-high-resolution-timer/">high-resolution timers</a>.</p>
<p>As a simple illustration, consider that we want to measure the time taken for the execution of a kernel named <code>fooKernel</code>. First, we create CUDA events to handle the begin and end times of the kernel execution:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">cudaEvent_t</span> beginEvent;
<span class="dt">cudaEvent_t</span> endEvent;

cudaEventCreate( &amp;beginEvent );
cudaEventCreate( &amp;endEvent );</code></pre></div>
<p>We then record the begin and end times of the kernel execution:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">cudaEventRecord( beginEvent, <span class="dv">0</span> );
fooKernel&lt;&lt;&lt; x, y &gt;&gt;&gt;( z, w );
cudaEventRecord( endEvent, <span class="dv">0</span> );</code></pre></div>
<p>Finally, we wait for the completion of the recording of the end event in the CUDA stream. After that, we compute the time elapsed between the recorded begin and end times to obtain the kernel execution time:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">cudaEventSynchronize( endEvent );

<span class="dt">float</span> timeValue;
cudaEventElapsedTime( &amp;timeValue, beginEvent, endEvent );

cout &lt;&lt; <span class="st">&quot;Time: &quot;</span> &lt;&lt; timeValue &lt;&lt; endl;</code></pre></div>
<p>The begin and end events can be reused any number of times in the program. When we do not need them anymore, they should be destroyed:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">cudaEventDestroy( beginEvent );
cudaEventDestroy( endEvent );</code></pre></div>
<p>A simple <code>CudaTimer</code> class that implements this usage can be seen <a href="http://bitbucket.org/ashwin/cudatimer/">here</a>.</p>
<p><strong>Tried with</strong>: CUDA 3.2</p>
<hr />
<p><a href="rss.xml">RSS</a> - <a href="mailto:codeyarns@gmail.com">Contact</a></p>
</body>
</html>
