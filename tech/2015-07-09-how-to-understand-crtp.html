<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Ashwin Nanjappa" />
  <title>A simple example to understand CRTP</title>
  <style type="text/css">code{white-space: pre;}</style>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-143311697-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
  
    gtag('config', 'UA-143311697-1');
  </script>
</head>
<body>
<div id="header">
<h1 class="title">A simple example to understand CRTP</h1>
<h2 class="author">Ashwin Nanjappa</h2>
<h3 class="date">2015-07-09 12:28:00+00:00</h3>
</div>
<p><strong>Dynamic polymorphism</strong> (or <strong>runtime polymorphism</strong>) using <strong>virtual functions</strong> in C++ is a great savior. However, a tiny fraction of applications might be affected by its disadvantages: an extra function call overhead and space occupied by a vtable pointer in every object.</p>
<p>For most of these applications, there might be no better choice than virtual functions, they will need to grin and bear it. But among these applications, there might be a further tiny fraction whose problem just might be elegantly solved using a <strong>static polymorphism</strong> technique called <strong>Curiously Recurring Template Pattern (CRTP)</strong>. It is also called the <strong>Barton-Nackman trick</strong>, since this duo introduced it for the first time in their 1997 book <strong>Scientific and Engineering C++</strong> (Section 12.6: Restricted Template Expansion).</p>
<p>The web is full of articles (like <a href="http://eli.thegreenplace.net/2011/05/17/the-curiously-recurring-template-pattern-in-c/">this</a>) and code explaining CRTP. While I could understand how the code worked, none of them explained what problem this trick was solving. In other words, I did not see the <strong>motivation</strong> for using this trick.</p>
<p>It is only when I went back to the source, i.e., the Barton-Nackman book that I hit pay dirt. They actually describe a contrived problem which this trick solves. However, their code examples were still quite obscure, so to understand them I created a simpler example, which I describe below.</p>
<h1 id="problem">Problem</h1>
<ul>
<li>Say, we have a class hierarchy with <code>Creature</code> base class and thousands of species classes derived from it. As an example, <code>Bird</code> and <code>Fish</code> are both derived from it.</li>
</ul>
<pre><code>struct Creature {};
struct Bird: Creature {};
struct Fish: Creature {};</code></pre>
<ul>
<li><p>Species like <code>Bird</code> and <code>Fish</code> have some common features (say <code>eye_num</code>) and some specialized features (say <code>wing_num</code> for <code>Bird</code> and <code>fin_num</code> for <code>Fish</code>). If this were not the case, there would be no need to arrange them in a hierarchy.</p></li>
<li><p>Suppose we want to write <strong>equality</strong> (<code>==</code>) and <strong>inequality</strong> (<code>!=</code>) comparison methods to compare any two objects of <strong>same species</strong>. That is to compare two <code>Bird</code> objects or two <code>Fish</code> objects. Also assume that inequality in this case is nothing but the negation of equality, but we want this inequality method anyway to write elegant code. We want to have the most maintainable and least amount of code that can achieve this:</p></li>
</ul>
<pre><code>Bird b1, b2, b3;
// ...
if (b1 == b2) // Do something
if (b2 != b3) // Do something</code></pre>
<h1 id="solutions">Solutions</h1>
<p>Let us see different ways this can be solved elegantly:</p>
<ul>
<li><p><strong>Solution 1:</strong> Create pure-virtual <code>==</code> method in <code>Creature</code> and override it in all the derived classes. Create <code>!=</code> method only in <code>Creature</code> that calls the equality method. For <code>N</code> derived classes, this would entail writing <code>N</code> equality methods and <code>1</code> inequality method. This is the perfect solution. However, we started this article with the assumption that its performance is not optimal for our application (see above).</p></li>
<li><p><strong>Solution 2:</strong> Create non-virtual <code>==</code> and <code>!=</code> operator methods in <code>Creature</code>. This means we write just <code>1</code> equality and <code>1</code> inequality method. Problem: This will take <code>Creature</code> as input, so features specific to <code>Bird</code> or <code>Fish</code> cannot be compared. This is useless because <strong>any reasonable equality test should be type dependent</strong>.</p></li>
<li><p><strong>Solution 3:</strong> Create non-virtual <code>==</code> operator methods in both <code>Bird</code> and <code>Fish</code>. Problem is that you will now need to create the non-virtual <code>!=</code> method also in <strong>all</strong> the derived classes! This means writing <code>N</code> equality and <code>N</code> inequality methods. Too much work!</p></li>
<li><p><strong>Solution 4:</strong> Use CRTP as shown in the code below. Both equality and inequality tests are fully type dependent. However, note that the inequality test is only written once in the base class. So, we end up writing <code>N + 1</code> equality and <code>1</code> inequality methods. This is optimal. The peculiar feature you can use to identify a CRTP is a type passing itself as template type to the base type it is deriving from, as seen in <code>Bird</code> and <code>Fish</code> below.</p></li>
</ul>
<p>[gist https://gist.github.com/ashwin/4f270ccde1e39218b306 /]</p>
<p>I hope this example helped you understand this trick! :-)</p>
</body>
</html>
