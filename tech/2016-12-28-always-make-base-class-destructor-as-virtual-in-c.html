<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Ashwin Nanjappa" />
  <title>Always make base class destructor as virtual in C++</title>
  <style type="text/css">code{white-space: pre;}</style>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-143311697-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
  
    gtag('config', 'UA-143311697-1');
  </script>
</head>
<body>
<div id="header">
<h1 class="title">Always make base class destructor as virtual in C++</h1>
<h2 class="author">Ashwin Nanjappa</h2>
<h3 class="date">2016-12-28 14:16:49+00:00</h3>
</div>
<p>TLDR: The title of this post says it all!</p>
<p>If you are having a class hierarchy, with base class and derived classes, then try to always <strong>make the base class destructor as virtual</strong>.</p>
<p>I recently noticed an application having a serious memory leak after merging some code. Other than the leak, everything else about the code was executing fine! After debugging the code, the culprit turned out to be a base class destructor that was not virtual. If only the above rule had been followed diligently, the error would have been caught easily.</p>
<p>Why this rule? The reason for this rule is pretty simple. A <strong>derived class destructor</strong> might be deallocating objects or freeing memory that it had allocated earlier during its creation or execution. Now think about the scenario where this derived class object is held using a base class pointer and it is freed.</p>
<ul>
<li><p><strong>If base class destructor is not virtual:</strong> Only the base class destructor is called, thus causing a memory leak.</p></li>
<li><p><strong>If base class destructor is virtual:</strong> The derived class destructor is called first (thus freeing its allocated objects correctly) before the trail of destruction heads up the chain of hierarchy, ending in the base class destructor. This is the intended correct behavior.</p></li>
</ul>
<p>Here is a code example that illustrates this scenario:</p>
<p>https://gist.github.com/ashwin/f0868a27e9a1f91ab713e3d977f871cd</p>
</body>
</html>
